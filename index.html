<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Real-Time Tic-Tac-Toe</title>
    <!-- Load Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Custom styles for X and O */
        .cell {
            position: relative;
        }
        .cell.x::before {
            content: 'X';
            color: #60a5fa; /* Tailwind blue-400 */
        }
        .cell.o::before {
            content: 'O';
            color: #f472b6; /* Tailwind pink-400 */
        }
        /* Simple loading spinner */
        .loader {
            border: 4px solid #f3f3f3;
            border-top: 4px solid #3498db;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        /* Style for chat window to ensure scroll works */
        #chat-window {
            height: 200px;
        }
    </style>
</head>
<body class="bg-gray-900 text-white font-sans flex items-center justify-center min-h-screen p-4">

    <div class="w-full max-w-md bg-gray-800 rounded-2xl shadow-2xl p-6 sm:p-8">

        <!-- 1. Loading / Auth Screen -->
        <div id="auth-screen" class="text-center">
            <div class="loader mx-auto"></div>
            <p class="mt-4 text-lg font-semibold text-gray-300">Connecting to game server...</p>
            <p class="mt-1 text-sm text-gray-500">Please wait.</p>
        </div>

        <!-- 2. Lobby Screen -->
        <div id="lobby-screen" class="hidden space-y-6">
            <h1 class="text-3xl font-bold text-center text-white">Real-Time Tic-Tac-Toe</h1>
            <p class="text-center text-gray-400">Your User ID: <strong id="user-id" class="text-gray-200 select-all">...</strong></p>
            
            <div>
                <button id="create-game-btn" class="w-full bg-blue-600 hover:bg-blue-700 text-white font-bold py-3 px-4 rounded-lg shadow-lg transition duration-200 ease-in-out transform hover:-translate-y-0.5">
                    Create New Game
                </button>
            </div>
            
            <div class="relative flex items-center justify-center">
                <div class="absolute inset-0 flex items-center" aria-hidden="true">
                    <div class="w-full border-t border-gray-600"></div>
                </div>
                <div class="relative flex justify-center">
                    <span class="px-3 bg-gray-800 text-sm font-medium text-gray-400">OR</span>
                </div>
            </div>

            <div class="space-y-3">
                <input type="text" id="join-game-input" placeholder="Enter Game ID..." class="w-full bg-gray-700 border border-gray-600 text-white px-4 py-3 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500">
                <button id="join-game-btn" class="w-full bg-green-600 hover:bg-green-700 text-white font-bold py-3 px-4 rounded-lg shadow-lg transition duration-200 ease-in-out transform hover:-translate-y-0.5">
                    Join Game
                </button>
                <p id="lobby-error" class="text-red-400 text-sm text-center"></p>
            </div>
        </div>

        <!-- 3. Game Screen -->
        <div id="game-screen" class="hidden">
            <h1 class="text-2xl font-bold text-center mb-2">Tic-Tac-Toe</h1>
            <p class="text-center text-gray-400 text-sm mb-1">Share this Game ID:</p>
            <p id="game-id-display" class="text-center text-lg font-semibold text-yellow-300 select-all mb-4">...</p>
            
            <p id="game-status" class="text-center text-xl font-semibold mb-4 min-h-[28px]">Waiting for opponent...</p>
            
            <div id="board" class="grid grid-cols-3 gap-2 sm:gap-3 aspect-square max-w-xs mx-auto mb-4">
                <!-- Cells will be generated by JS -->
            </div>
            
            <button id="reset-game-btn" class="hidden w-full bg-yellow-600 hover:bg-yellow-700 text-white font-bold py-2 px-4 rounded-lg shadow-lg transition duration-200 ease-in-out">
                Play Again
            </button>
            
            <!-- CHAT WINDOW -->
            <div class="mt-6 border-t border-gray-700 pt-4">
                <h3 class="text-xl font-semibold mb-2 text-gray-200">Game Chat</h3>
                <div id="chat-window" class="h-48 overflow-y-auto p-3 bg-gray-700 rounded-lg mb-3 space-y-2">
                    <!-- Messages will be rendered here -->
                </div>
                <div class="flex space-x-2">
                    <input type="text" id="chat-input" placeholder="Type a message..." class="flex-grow bg-gray-600 border border-gray-500 text-white px-3 py-2 rounded-lg focus:outline-none focus:ring-2 focus:ring-pink-500">
                    <button id="send-chat-btn" class="bg-pink-600 hover:bg-pink-700 text-white font-bold py-2 px-4 rounded-lg transition duration-200 ease-in-out">
                        Send
                    </button>
                </div>
            </div>
            <!-- END CHAT WINDOW -->

            <button id="leave-game-btn" class="w-full bg-gray-600 hover:bg-gray-700 text-white font-bold py-3 px-4 rounded-lg shadow-lg transition duration-200 ease-in-out mt-4">
                Back to Lobby
            </button>
        </div>

    </div>

    <!-- Firebase SDK -->
    <script type="module">
        // Import Firebase modules
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { 
            getAuth, 
            signInAnonymously, 
            signInWithCustomToken, 
            onAuthStateChanged 
        } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { 
            getFirestore, 
            doc, 
            getDoc, 
            addDoc, 
            setDoc, 
            updateDoc, 
            onSnapshot, 
            collection,
            query, // Added for chat ordering
            orderBy, // Added for chat ordering
            serverTimestamp, // Added for chat timestamp
            setLogLevel 
        } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

        // --- DOM Elements ---
        const authScreen = document.getElementById('auth-screen');
        const lobbyScreen = document.getElementById('lobby-screen');
        const gameScreen = document.getElementById('game-screen');
        
        const userIdSpan = document.getElementById('user-id');
        const createGameBtn = document.getElementById('create-game-btn');
        const joinGameInput = document.getElementById('join-game-input');
        const joinGameBtn = document.getElementById('join-game-btn');
        const lobbyError = document.getElementById('lobby-error');
        
        const gameIdDisplay = document.getElementById('game-id-display');
        const gameStatus = document.getElementById('game-status');
        const boardDiv = document.getElementById('board');
        const resetGameBtn = document.getElementById('reset-game-btn');
        const leaveGameBtn = document.getElementById('leave-game-btn');

        // NEW CHAT ELEMENTS
        const chatWindow = document.getElementById('chat-window');
        const chatInput = document.getElementById('chat-input');
        const sendChatBtn = document.getElementById('send-chat-btn');

        // --- Firebase Config & State ---
        
        // This configuration is used ONLY when running outside of the Canvas environment
        const externalFirebaseConfig = {
          apiKey: "AIzaSyAQIba84-U3-PbPzGWLFPxZ8AAdNBsSMwc",
          authDomain: "multiplayer-tic-tac-toe-2e7ce.firebaseapp.com",
          projectId: "multiplayer-tic-tac-toe-2e7ce",
          storageBucket: "multiplayer-tic-tac-toe-2e7ce.firebasestorage.app",
          messagingSenderId: "834056843365",
          appId: "1:834056843365:web:55776c010ac57018a0168c",
          measurementId: "G-4QNR6SBVNK"
        };
        
        // These global variables are provided by the Canvas environment.
        const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-tictactoe-app';
        const initialAuthToken = typeof __initial_auth_token !== 'undefined' ? __initial_auth_token : null;

        const firebaseConfig = (typeof __firebase_config !== 'undefined' && __firebase_config !== '{}' && __firebase_config !== '') 
            ? JSON.parse(__firebase_config) 
            : externalFirebaseConfig;


        let auth, db, gameCollection;
        let userId = null;
        let currentGameId = null;
        let playerSymbol = null; // 'X' or 'O'
        let gameUnsubscribe = null; // Function to stop listening to game updates
        let chatUnsubscribe = null; // NEW: Function to stop listening to chat updates
        let currentGameData = null; // Caches the latest game data

        // --- Firebase Initialization ---
        async function initializeFirebase() {
            try {
                const app = initializeApp(firebaseConfig);
                auth = getAuth(app);
                db = getFirestore(app);
                setLogLevel('debug'); // Enable Firestore logging

                // This collection MUST be public for matchmaking
                const gameCollectionPath = `/artifacts/${appId}/public/data/tictactoe_games`;
                gameCollection = collection(db, gameCollectionPath);

                setupAuthListener();
            } catch (error) {
                console.error("Firebase Init Error:", error);
                authScreen.innerHTML = `<p class="text-red-400">Error connecting to server. Please refresh or check the console.</p>`;
            }
        }

        function setupAuthListener() {
            onAuthStateChanged(auth, async (user) => {
                if (user) {
                    userId = user.uid;
                    userIdSpan.textContent = userId;
                    showScreen('lobby');
                } else {
                    try {
                        if (initialAuthToken) {
                            // Use provided custom token for authentication (Canvas environment)
                            await signInWithCustomToken(auth, initialAuthToken);
                        } else {
                            // Fallback to anonymous sign-in (external deployment)
                            await signInAnonymously(auth);
                        }
                    } catch (error) {
                        console.error("Auth Error:", error);
                        authScreen.innerHTML = `<p class="text-red-400">Authentication failed. Please refresh.</p>`;
                    }
                }
            });
        }

        // --- Screen Management ---
        function showScreen(screenName) {
            authScreen.classList.add('hidden');
            lobbyScreen.classList.add('hidden');
            gameScreen.classList.add('hidden');

            if (screenName === 'auth') {
                authScreen.classList.remove('hidden');
            } else if (screenName === 'lobby') {
                lobbyScreen.classList.remove('hidden');
                lobbyError.textContent = '';
                joinGameInput.value = '';
                // Ensure chat listener is off when in lobby
                if (chatUnsubscribe) { chatUnsubscribe(); chatUnsubscribe = null; }
            } else if (screenName === 'game') {
                gameScreen.classList.remove('hidden');
            }
        }

        // --- Lobby Logic (Unchanged) ---
        async function createGame() {
            createGameBtn.disabled = true;
            lobbyError.textContent = '';
            
            const newGame = {
                board: Array(9).fill(''),
                currentPlayer: 'X',
                players: {
                    'X': userId,
                    'O': null
                },
                status: 'waiting', // 'waiting', 'active', 'won', 'draw'
                winner: null, // 'X', 'O', or null
            };

            try {
                const docRef = await addDoc(gameCollection, newGame);
                currentGameId = docRef.id;
                playerSymbol = 'X';
                subscribeToGame(currentGameId);
                showScreen('game');
            } catch (error) {
                console.error("Error creating game:", error);
                lobbyError.textContent = 'Could not create game. Check Firestore permissions.';
            } finally {
                createGameBtn.disabled = false;
            }
        }

        async function joinGame() {
            const gameId = joinGameInput.value.trim();
            if (!gameId) {
                lobbyError.textContent = 'Please enter a Game ID.';
                return;
            }

            joinGameBtn.disabled = true;
            lobbyError.textContent = '';
            
            try {
                const gameDocRef = doc(db, gameCollection.path, gameId);
                const gameDoc = await getDoc(gameDocRef);

                if (!gameDoc.exists()) {
                    lobbyError.textContent = 'Game not found. Check the ID.';
                    return;
                }

                const gameData = gameDoc.data();

                if (gameData.players.O) {
                    lobbyError.textContent = 'This game is already full.';
                    return;
                }
                
                if (gameData.players.X === userId) {
                    lobbyError.textContent = 'You are already Player X in this game.';
                    return;
                }

                await updateDoc(gameDocRef, {
                    'players.O': userId,
                    status: 'active'
                });

                currentGameId = gameId;
                playerSymbol = 'O';
                subscribeToGame(currentGameId);
                showScreen('game');

            } catch (error) {
                console.error("Error joining game:", error);
                lobbyError.textContent = 'Could not join game. Please try again.';
            } finally {
                joinGameBtn.disabled = false;
            }
        }

        // --- Game Logic ---
        function subscribeToGame(gameId) {
            // Unsubscribe from any previous listeners
            if (gameUnsubscribe) { gameUnsubscribe(); }
            if (chatUnsubscribe) { chatUnsubscribe(); } // IMPORTANT: Unsubscribe chat too!
            
            gameIdDisplay.textContent = gameId;
            const gameDocRef = doc(db, gameCollection.path, gameId);
            
            // 1. Subscribe to Game state
            gameUnsubscribe = onSnapshot(gameDocRef, (doc) => {
                if (doc.exists()) {
                    currentGameData = doc.data();
                    renderGame(currentGameData);
                } else {
                    leaveGame();
                    console.error("The game document was removed."); 
                }
            }, (error) => {
                console.error("Game Snapshot error:", error);
                leaveGame();
            });

            // 2. Subscribe to Chat messages
            subscribeToChat(gameId); 
        }

        function renderGame(gameData) {
            // Render board
            boardDiv.innerHTML = '';
            gameData.board.forEach((cell, index) => {
                const cellDiv = document.createElement('div');
                cellDiv.className = 'cell bg-gray-700 rounded-lg flex items-center justify-center text-6xl font-bold aspect-square transition duration-150 ease-in-out';
                if (cell) {
                    cellDiv.classList.add(cell.toLowerCase()); // Adds 'x' or 'o' class for CSS styling
                }
                
                // Set cursor and clickability based on game state
                if (!cell && gameData.status === 'active' && gameData.currentPlayer === playerSymbol) {
                    cellDiv.classList.add('cursor-pointer', 'hover:bg-gray-600');
                    cellDiv.onclick = () => onCellClick(index);
                } else {
                    cellDiv.classList.add('cursor-not-allowed');
                    cellDiv.onclick = null; 
                }
                
                boardDiv.appendChild(cellDiv);
            });

            // Render status
            resetGameBtn.classList.add('hidden');
            switch (gameData.status) {
                case 'waiting':
                    gameStatus.textContent = 'Waiting for opponent (O) to join...';
                    gameStatus.className = 'text-center text-xl font-semibold mb-4 min-h-[28px] text-yellow-400';
                    break;
                case 'active':
                    const statusText = gameData.currentPlayer === playerSymbol ? 'Your turn' : "Opponent's turn";
                    gameStatus.textContent = `${statusText} (${gameData.currentPlayer})`;
                    gameStatus.className = `text-center text-xl font-semibold mb-4 min-h-[28px] ${gameData.currentPlayer === playerSymbol ? 'text-green-400' : 'text-gray-400'}`;
                    break;
                case 'won':
                    gameStatus.textContent = gameData.winner === playerSymbol ? 'You won!' : `You lost! (${gameData.winner} wins)`;
                    gameStatus.className = `text-center text-xl font-semibold mb-4 min-h-[28px] ${gameData.winner === playerSymbol ? 'text-green-400' : 'text-red-400'}`;
                    if (playerSymbol === 'X') { resetGameBtn.classList.remove('hidden'); }
                    break;
                case 'draw':
                    gameStatus.textContent = "It's a draw!";
                    gameStatus.className = 'text-center text-xl font-semibold mb-4 min-h-[28px] text-blue-400';
                    if (playerSymbol === 'X') { resetGameBtn.classList.remove('hidden'); }
                    break;
            }
        }

        async function onCellClick(index) {
            // Check conditions
            if (!currentGameData || currentGameData.board[index] !== '' || 
                currentGameData.status !== 'active' || currentGameData.currentPlayer !== playerSymbol) {
                return;
            }

            const newBoard = [...currentGameData.board];
            newBoard[index] = playerSymbol;

            const [newStatus, newWinner] = checkGameEnd(newBoard, playerSymbol);

            const updateData = {
                board: newBoard,
                status: newStatus,
                winner: newWinner,
                // Only switch player if the game is still active
                currentPlayer: newStatus === 'active' ? (playerSymbol === 'X' ? 'O' : 'X') : currentGameData.currentPlayer
            };
            
            try {
                const gameDocRef = doc(db, gameCollection.path, currentGameId);
                await updateDoc(gameDocRef, updateData);
            } catch (error) {
                console.error("Error making move. Please try again:", error);
            }
        }

        function checkGameEnd(board, player) {
            const winCombos = [
                [0, 1, 2], [3, 4, 5], [6, 7, 8], // Rows
                [0, 3, 6], [1, 4, 7], [2, 5, 8], // Columns
                [0, 4, 8], [2, 4, 6]  // Diagonals
            ];

            for (const combo of winCombos) {
                const [a, b, c] = combo;
                if (board[a] === player && board[b] === player && board[c] === player) {
                    return ['won', player]; 
                }
            }

            if (!board.includes('')) {
                return ['draw', null];
            }

            return ['active', null];
        }

        async function resetGame() {
            if (playerSymbol !== 'X' || !currentGameData || (currentGameData.status !== 'won' && currentGameData.status !== 'draw')) {
                return; 
            }

            try {
                const gameDocRef = doc(db, gameCollection.path, currentGameId);
                await updateDoc(gameDocRef, {
                    board: Array(9).fill(''),
                    currentPlayer: 'X', 
                    status: 'active',
                    winner: null
                });
            } catch (error) {
                console.error("Error resetting game:", error);
            }
        }

        function leaveGame() {
            if (gameUnsubscribe) { gameUnsubscribe(); gameUnsubscribe = null; }
            if (chatUnsubscribe) { chatUnsubscribe(); chatUnsubscribe = null; } // IMPORTANT: Unsubscribe chat
            
            currentGameId = null;
            playerSymbol = null;
            currentGameData = null;
            showScreen('lobby');
        }


        // --- CHAT LOGIC ---

        // Helper to get chat collection reference (subcollection of the game document)
        function getChatCollectionRef(gameId) {
            return collection(db, gameCollection.path, gameId, 'messages');
        }

        function subscribeToChat(gameId) {
            if (chatUnsubscribe) {
                chatUnsubscribe();
            }

            const chatRef = getChatCollectionRef(gameId);
            // Query to order messages by timestamp ascending
            const q = query(chatRef, orderBy('timestamp', 'asc'));

            chatUnsubscribe = onSnapshot(q, (snapshot) => {
                const messages = [];
                snapshot.forEach(doc => {
                    messages.push(doc.data());
                });
                renderChat(messages);
            }, (error) => {
                console.error("Chat snapshot error:", error);
            });
        }

        function renderChat(messages) {
            chatWindow.innerHTML = '';
            messages.forEach(msg => {
                const isMyMessage = msg.senderId === userId;
                const messageDiv = document.createElement('div');
                
                // Message alignment: right for user, left for opponent
                messageDiv.className = `flex ${isMyMessage ? 'justify-end' : 'justify-start'}`;
                
                const bubble = document.createElement('div');
                bubble.className = `max-w-[80%] px-3 py-2 rounded-xl text-sm shadow break-words whitespace-pre-wrap ${
                    isMyMessage 
                        ? 'bg-pink-600 text-white rounded-br-none' 
                        : 'bg-gray-600 text-gray-100 rounded-tl-none'
                }`;
                
                // Format time if timestamp exists and is not a placeholder
                let time = '';
                if (msg.timestamp && typeof msg.timestamp.toMillis === 'function') {
                    time = new Date(msg.timestamp.toMillis()).toLocaleTimeString('en-US', { hour: '2-digit', minute: '2-digit' });
                }
                
                // Show "You" for the local user, "Opponent" otherwise
                bubble.innerHTML = `
                    <p class="font-semibold text-xs mb-0.5">${isMyMessage ? 'You' : 'Opponent'}</p>
                    <p class="text-base">${msg.text}</p>
                    <span class="block text-[10px] mt-1 text-right opacity-70">${time}</span>
                `;
                
                messageDiv.appendChild(bubble);
                chatWindow.appendChild(messageDiv);
            });
            // Auto-scroll to the bottom of the chat window
            chatWindow.scrollTop = chatWindow.scrollHeight;
        }

        async function sendMessage() {
            const text = chatInput.value.trim();
            if (!text || !currentGameId) return;

            // Prevent double-send
            chatInput.disabled = true;
            sendChatBtn.disabled = true;

            try {
                const chatRef = getChatCollectionRef(currentGameId);
                await addDoc(chatRef, {
                    text: text,
                    senderId: userId,
                    timestamp: serverTimestamp(), // Use server timestamp for reliable ordering
                });
                chatInput.value = ''; // Clear input on success
            } catch (error) {
                console.error("Error sending message:", error);
                // In a real app, you'd show a message to the user here.
            } finally {
                chatInput.disabled = false;
                sendChatBtn.disabled = false;
                chatInput.focus();
            }
        }


        // --- Event Listeners ---
        createGameBtn.onclick = createGame;
        joinGameBtn.onclick = joinGame;
        leaveGameBtn.onclick = leaveGame;
        resetGameBtn.onclick = resetGame;

        // NEW CHAT EVENT LISTENERS
        sendChatBtn.onclick = sendMessage;
        chatInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                e.preventDefault(); // Prevent new line in input
                sendMessage();
            }
        });

        // --- Start App ---
        initializeFirebase();

    </script>
</body>
</html>

